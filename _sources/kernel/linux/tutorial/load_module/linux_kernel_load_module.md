# 如何让Linux内核编译驱动模块并且加载驱动模块

> 参考资料：
>
> https://zhuanlan.zhihu.com/p/443071338
>
> https://blog.csdn.net/luckyapple1028/article/details/44261391
>
> https://blog.csdn.net/hbuxiaofei/article/details/128266554

在Linux Kernel Fuzzing的时候，我们经常需要做的一个操作就是反复地加载（Load）和卸载（Unload）一个内核驱动模块。这应该怎么做呢？

## Linux内核编译

为了后续能够加载或卸载内核模块，我们在编译Linux内核的时候就需要修改编译选项，一般来说我们选择使用`make allmodconfig`即可，该配置会尽量地启动内核模块，同时将很多驱动模块都编译成`.ko`以便后续动态加载。

此外还有`defconfig`， `olddefconfig`等，他们的作用和介绍如下：

1. **`make defconfig`**：
   - **用途**：生成一个默认的配置文件，启用所有支持当前体系结构的功能。
   - **适用场景**：适合大多数情况，提供一个全面的基础内核。

2. **`make olddefconfig`**：
   - **用途**：根据旧的配置文件（如`.config`）生成新的默认配置，并处理新增或删除的选项。
   - **适用场景**：在升级或更新时保留原有设置，同时应用新版本的默认值。

3. **`make allnoconfig`**：
   - **用途**：生成一个最小化的配置文件，禁用所有模块和功能。
   - **适用场景**：用于调试或极简环境，快速测试基础功能。

4. **`make allmodconfig`**：
   - **用途**：尽可能多的启用模块，并将它们作为动态加载的模块。
   - **适用场景**：增加系统的灵活性，便于在运行时动态加载模块。

生成了`.config`之后，就可以使用`make -j`进行编译了。编译之后再使用`make modules_install`便可以在目录`/lib/modules/$(uname -r)/`下看到你编译出的内核驱动模块了。

## 加载模块

Linux系统中的模块管理命令有`insmod`、`rmmod`和`modprobe`等，它们各有其功能和用途，以下是对它们的详细介绍：

### 1. `insmod` 命令
- **功能**：用于将指定的内核模块加载到内存中。该命令直接处理模块文件（通常以`.ko`为扩展名）。
- **语法**：
  ```bash
  sudo insmod /path/to/module.ko
  ```
- **特点**：
  - 不检查依赖关系，因此需要确保所有依赖的模块已经加载。
  - 需要root权限执行。

### 2. `rmmod` 命令
- **功能**：用于从内存中卸载指定的内核模块。
- **语法**：
  ```bash
  sudo rmmod module_name
  ```
- **特点**：
  - 不处理依赖关系，如果模块被其他模块或设备使用，可能无法卸载并显示错误信息。

### 3. `modprobe` 命令
- **功能**：高级工具，用于加载和卸载内核模块，并自动处理模块的依赖关系。
- **语法**：
  - 加载模块：
    ```bash
    sudo modprobe module_name
    ```
  - 卸载模块：
    ```bash
    sudo modprobe -r module_name
    ```
- **特点**：
  - 检查并加载所有必要的依赖模块，简化了模块管理。
  - 支持别名，可以通过配置文件定义模块的别名。

### 区别与使用建议
- **`insmod` vs `modprobe`**：`insmod`是底层工具，适合已知无依赖的情况；而`modprobe`是高层工具，自动处理依赖，适合日常使用。
- **`rmmod` vs `modprobe -r`**：`modprobe -r`在卸载时会一并卸载依赖模块，更方便但需谨慎。
- **`depmod`**：当内核版本更新、添加新模块或修改现有模块后，需要重新生成依赖关系缓存，不然使用`modprobe xxx`会出现`File xxx.ko not found ...`提示对应模块找不到。这时候只需要使用命令`depmod -a`即可，该命令会分析所有模块并生成完整的缓存文件

### 注意事项
- 在加载或卸载模块前，确保不会影响系统稳定性。例如，避免在运行设备驱动时卸载相关模块。
- 使用`lsmod`命令检查当前加载的模块，并使用`dmesg`查看加载/卸载过程中的错误信息。

## 常见问题

如果在加载模块的时候出现问题

```console
insmod: ERROR: could not insert module ice.ko: Invalid module format
.gnu.linkonce.this_module section size must match the kernel's built struct module size at run time
```

这个问题可能是因为编译该模块时使用的内核编译选项和当前系统正在使用的内核编译选项不一样，这时候需要修改内核编译选项重新编译一下内核或该模块，保证二者的编译选项一致即可。

## 驱动模块加载流程

在Linux中，驱动程序是作为一个模块加载的。之前我们已经介绍了如何编译出一个驱动模块，接下来我们就从源码来看看驱动模块是如何加载的。

简单来说，驱动程序的加载分为`静态加载`和`动态加载`两种方式。静态加载就是把驱动程序编译进入内核，在内核启动的时候就加载，而动态加载就是把驱动程序编译成模块（.ko文件），在需要的时候再使用`insmod`，`modprobe`等命令加载，在不需要时再用`rmmod`卸载。当我们在调整编译选项时，可以看到其中很多驱动有关的选项有\[Y/M/N\]三个，其中Y就是将该模块编译进入内核，M就是将该模块编译成模块，N就是不编译该模块。

### 驱动加载

#### 静态加载过程（冷加载）

#### 动态加载过程（热加载）

### 驱动匹配

### 驱动自动加载（热加载）






